<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>So You Want to Functional Programming :: Terminal</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Introduction Hello there, poor soul! How come you found your way to this post? Are you perhaps unhappy with the way programming is done nowadays? Did you perhaps hear someone say that functional programming has all the benefits like:
Simplifying your projects Removing a class of errors and bugs Bringing back joy of programming of early days Well, whether those claims are true or not, you will have to see them for yourself." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/so-you-want-to-fp/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="So You Want to Functional Programming">
<meta property="og:description" content="Introduction Hello there, poor soul! How come you found your way to this post? Are you perhaps unhappy with the way programming is done nowadays? Did you perhaps hear someone say that functional programming has all the benefits like:
Simplifying your projects Removing a class of errors and bugs Bringing back joy of programming of early days Well, whether those claims are true or not, you will have to see them for yourself." />
<meta property="og:url" content="/posts/so-you-want-to-fp/" />
<meta property="og:site_name" content="Terminal" />

  
  
  <meta property="og:image" content="/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-01-19 01:03:00 &#43;0900 JST" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/showcase" >Showcase</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/so-you-want-to-fp/">So You Want to Functional Programming</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-01-19</time></div>

  
  


  

  <div class="post-content"><div>
        <h1 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Hello there, poor soul!
How come you found your way to this post?
Are you perhaps unhappy with the way programming is done nowadays?
Did you perhaps hear someone say that functional programming has all the benefits like:</p>
<ul>
<li>Simplifying your projects</li>
<li>Removing a class of errors and bugs</li>
<li>Bringing back joy of programming of early days</li>
</ul>
<p>Well, whether those claims are true or not, you will have to see them for yourself.
One interesting thing happening is:</p>
<ol>
<li>people who are not into FP think those who are into FP are pretentious pricks who want to feel themselves smarter, while</li>
<li>the guys who are into FP don&rsquo;t understand all the resistance when there&rsquo;s such a wealth of good things about FP and it is actually not as difficult as many people claim.</li>
</ol>
<p>Well, it seems kinda accurate to me.</p>
<p>There was a period in time when I was &ldquo;aggressive&rdquo; trying to get people learn Functional Programming.
Because of me, some people are probably never crossing to our side.</p>
<p>Oopsie-daisy.</p>
<p>But in my defence, some of those people saw the benefits of those ideas, but are in a stage of their lives when they can&rsquo;t afford to learn functional programming.</p>
<p>That is a valid gripe with functional programming that those who are on the other side have: there&rsquo;s just too much to learn.
Of course, you can use <code>map</code>, <code>filter</code>, <code>fold</code>, recursion, immutability, etc. to spice up your code with some functional flavor.
But the problem most advanced of us have with this, is that you won&rsquo;t understand what you&rsquo;re doing and whether the solution you&rsquo;re deploying is the proper one.
Essentially, you&rsquo;re not getting what you were promised: understanding.
But it is too difficult to get all of it right away (thanks OOP).
Blindly deploying all the tools that you&rsquo;ve learned in hopes it will work is not such a good approach, because high chances it is not going to work, but somehow it is the fault of the FP folk who proposed the idea, not the person who couldn&rsquo;t figure out how to use the idea properly.
Speaking from the experience of a friend who tried to make the code in Dart robust by employing a <code>Either</code> type, and who later regretted it, since Dart is wasn&rsquo;t developed with FP ideas in mind.</p>
<p>But the problem still persists: functional programming is difficult to grasp.
In truth, functional programming ideas are simple, and possibly much simpler than OOP ideas to understand (I mean understand, not just &ldquo;ahh, I see&rdquo; and forget the next 15 minutes).
But for some our brains are adamant in nogg comprehending those simple ideas.
And I don&rsquo;t know why.
Might make a good PhD thesis in Neuroscience, who knows.</p>
<p>So I&rsquo;ll try my best to explain functional programming principles&hellip; in Python.
Nowadays everyone and their grandmother seems to know Python, so it should be no problem.</p>
<h1 id="what-is-the-lesson">What is the lesson?<a href="#what-is-the-lesson" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The most important takeaway from this post is the perspective.
The correct one, hopefully.</p>
<p>The problem with learning functional programming is that its ideas lie on several spectrums of logic, math, computer science and engineering, simultaneously.
Its ideas are so deep, essentially like calculus, and are rediscovered again and again, by many different people, independently.
The book of &ldquo;Clean Code&rdquo; is essentially a pseudo-introduction into functional programming (not that reading that book helped me understand how to go about my code as a kid, but I really it nonetheless).</p>
<p>So yeah, there are many ways to look at the concept through many different lenses, and tugging on one concept affects or attracts other concepts and ideas.
That&rsquo;s why when you&rsquo;re learning functional programming, it feels like you have to learn a lot, simultaneously.
Because you kinda do.
Additionally, functional programming tends to attract people who like to explore ideas, which is nice, but they make bad teachers.</p>
<p>At the end of your (beginning of a) journey into functional programming, if you make it, is that you get a sense of understanding.
The world would never be the same.
You&rsquo;ll start to see things that weren&rsquo;t there before.
Like a sixth sense.
And you&rsquo;ll realize that the ideas were in fact quite simple (although not easy to grasp).</p>
<p>You won&rsquo;t get that understanding by just reading one blog post.
Or two.
Or ten.
Or even one or two books.
At least now.
People who get into functional programming claim that Elm is a great gateway drug into functional programming: it is easy and friendly.
The problem is that it is quite niche (for client-side frontend and compiles to JavaScript).
Unless you do just that, you&rsquo;re stuck.
So one of my aspirations is to create a general purpose programming language, that will be a bad functional programming language, but which will make a good start into FP, just like Elm does.
Unfortunately there isn&rsquo;t one (yet), so we&rsquo;ll be using Python.</p>
<p>Remember, the most important takeaway of this blog post is the perspective.
If you get the perspective, a lot of unconnected things will fall into place.</p>
<p>So, let&rsquo;s start.</p>
<h1 id="functions-purity-and-side-effects">Functions, Purity and Side-effects<a href="#functions-purity-and-side-effects" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Just like in OOP, the most basic building block is an object (or a class, I don&rsquo;t know), the most basic building block in functional programming is a&hellip; function.</p>
<p>Don&rsquo;t look at me like that: there are surprisingly many things that you can build with just functions.
In fact, Alonzo Church, academic supervisor of Alan Turing, discovered lambda calculus and showed that it is equivalent to <em>the</em> Turing Machine.
Essentially, what your fancy C++ and other languages can do, functional programming can also do.</p>
<p>The first important point:</p>
<pre tabindex="0"><code>Important point no. 1: Function is all you need
</code></pre><p>But not just any function.
What we like in functional programming is a <em>pure</em> function.
So, now we are getting jargons territory, let&rsquo;s quickly back it up with examples.</p>
<p>Let&rsquo;s imagine we are trying to write a function that takes the user&rsquo;s name and prints the message of the day:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd</span>(name):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>  motd(<span style="color:#e6db74">&#34;KtlTheBest&#34;</span>)
</span></span></code></pre></div><p>Now, while this example is purely imaginary, the code is emblematic of what people would usually write.
While it is fine, the question is, how do you <em>test</em> this?</p>
<p>&ldquo;What do you mean by <em>test</em>?&rdquo; I hear you asking.
What I&rsquo;m asking is why are you confident that this will work?
&ldquo;Well, I&rsquo;ll run the code and see the result printed in the terminal&hellip;&rdquo;.
Yeah, but when I was initially writing this code, I made a mistake.
I would have to run the code to see the bug.
But what if the code would be more involved?
Say, it would have many functions (or better say <em>procedures</em>) doing many things, tightly coupled and the only way you see the output is by pinging or calling some other guy sitting on another laptop checking the server response.
Doesn&rsquo;t sound so nice now, does it?</p>
<p>&ldquo;Well, that&rsquo;s how the things are&rdquo;.
But we as functional programmers would disagree.
We would say that the reason you are having problems is because most of your functions are <em>impure</em>.
For example:</p>
<ul>
<li><code>print()</code> is an impure function.</li>
<li><code>randint()</code> is an impure function.</li>
<li><code>time.now()</code> is an impure function.</li>
<li><code>input()</code> is an impure function.</li>
<li>Function that fails because it is Tuesday is an impure function.</li>
<li>Function that reads from a global variable is an impure function.</li>
<li>Function that changes the values of input arguments passed by reference is an impure function.</li>
</ul>
<p>Already, in a small function of one line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd</span>(name):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name))
</span></span></code></pre></div><p>&hellip; you&rsquo;re already experiencing problems.</p>
<p>So, how do we make this testable?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd_pure</span>(name)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name)
</span></span></code></pre></div><p>What we are doing instead of printing is <em>returning a string to print</em>.
Printing is not our responsibility now.</p>
<p>Now, to verify the code, we can write something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>  message <span style="color:#f92672">=</span> motd_pure(<span style="color:#e6db74">&#34;KtlTheBest&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">assert</span> message <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Hello, KtlTheBest! Have a nice day!&#34;</span>
</span></span><span style="display:flex;"><span>  print(message)
</span></span></code></pre></div><p>What we made, is essentially made an impure function a <em>pure</em> one.
But as a consequence, this function became <em>testable</em></p>
<p>We also wrote an <code>assert</code> statement that will print <strong>only</strong> if the function <code>motd_pure()</code> is correct (by some arbitrary definition).</p>
<p>And if you have very keen eyes, you&rsquo;ll realize that there&rsquo;s a bug in a <code>motd_pure</code>: I forgot a comma after <code>&quot;Hello&quot;</code>.</p>
<p>But instead of blindly relying on my (or someone else&rsquo;s) eyes, I can ask computer to verify the function and be 100% sure it works only when it is correct.</p>
<p>So with that, let&rsquo;s get into some definitions.</p>
<h2 id="what-is-purity">What is purity?<a href="#what-is-purity" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>When talking about purity, functional programmers refer to pure functions.
By pure functions we mean functions in mathematical sense:</p>
<pre tabindex="0"><code>f(x) = x * x
</code></pre><p>We can also say that pure functions:</p>
<ol>
<li>Output of the pure function <em>always</em> depends solely on <em>input</em> arguments.</li>
<li>It has no <em>observable</em> side-effects.</li>
</ol>
<p>Let&rsquo;s look at the function again.
If we try to substitute numbers, we get different values:</p>
<pre tabindex="0"><code>f(1)  = 1  * 1  = 1
f(2)  = 2  * 2  = 4
f(10) = 10 * 10 = 100
f(n)  = n  * n  = n * n
</code></pre><p>Here, the result of <code>f(x)</code> depends solely on <code>x</code>.
Another interesting observation is that we can evaluate <code>f(x)</code> infinitely many times, and the result would always be the same: <code>x * x</code>.</p>
<p>This is a nice property to have.</p>
<p>&ldquo;Are there functions that don&rsquo;t behave like that?&rdquo; you may ask.
To which I&rsquo;ll show you this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>DEBUG <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> DEBUG <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> x
</span></span></code></pre></div><p>Now, if we evaluate this function like this: <code>foo(3)</code>, we may get <code>9</code>, but when we run it again, <code>f(3) = -3</code>.
Now, we have two different values for <code>foo(3)</code>.
This is not a pure function.
This function has an implicit <em>state</em>.
Implicit, because it is not observable from the function signature (input and output arguments), but if you run it, you&rsquo;ll feel the effects (for example different values for the same input arguments).</p>
<p>Second line says that the function must not have <em>observable</em> side-effects.
Let me show you:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>I&rsquo;ll give you a little sneak-peek, but <em>mutation</em> of a variable (i.e. <code>x = 1; x = 2; assert x != 1</code>) is a <em>side-effect</em> and thus leads to impure functions.
So while we are doing a side-effect, we essentially have pure functions.</p>
<p>For the same list <code>l</code> the results of the functions would be the same.
On a side note, we are doing the order in different ways in both functions, but since the functions are pure and the addition is <em>commutative</em>, i.e. the <code>x + y = y + x</code>, we can say:</p>
<pre tabindex="0"><code>sum_left_to_right(l) == sum_right_to_left(l)
</code></pre><p>However, if we were to add <code>print(&quot;Currently on: {}&quot;.format(i))</code> into the loop, the functions would become impure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>First of all, the functions are doing printing, which is side-effect by definition.
But even if we compare by the side-effects, they would still be different, even if the sum is the same:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  to_print <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Currently on:</span>
</span></span><span style="display:flex;"><span>    to_print<span style="color:#f92672">.</span>push(i)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (sum, to_print)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  to_print <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Currently on:</span>
</span></span><span style="display:flex;"><span>    to_print<span style="color:#f92672">.</span>push(i)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (sum, to_print)
</span></span></code></pre></div><p>If we compare them, the results will not be the same (in general):</p>
<pre tabindex="0"><code>sum_left_to_right(l) != sum_right_to_left(l)        |l| &gt; 1
</code></pre><p>This is dandy and all, but what&rsquo;s the use, you may ask?
Well, to answer that, we need to cover one more case of side-effect: mutating variables.</p>
<p>You may have seen this millions of times:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>What this does, is that it &ldquo;creates&rdquo; a variable named <code>x</code> and assigns it a value of <code>1</code>.
After that it <em>mutates</em> its value to <code>x + 1</code>.</p>
<p>From the mathematical point of view this expression doesn&rsquo;t make sense.
There&rsquo;s no value of <code>x</code> in <code>ℤ</code>, <code>ℕ</code>, <code>ℚ</code>, <code>ℝ</code> or <code>ℂ</code> that has this property (except if you do modulo 1, but that&rsquo;s useless).</p>
<p>But the thing is, the ability to freely mutate state is the source of many software bugs.
Of course, you may not believe me, since I don&rsquo;t have enough experience writing software, but if you try to look at it yourself, you&rsquo;ll see that I&rsquo;m right.</p>
<p>As for me, everytime I am forced to write in Python or any similar languages with hard-to-understand semantics (i.e. you look at the code and have no idea what will happen), I dread inside.</p>
<p>Let&rsquo;s look at this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">...</span> <span style="color:#75715e"># some value</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># x = ???</span>
</span></span></code></pre></div><p>The thing is with Python, is that you don&rsquo;t know or can&rsquo;t be sure.
You don&rsquo;t know, and compiler doesn&rsquo;t know either.</p>
<p>Simple values like <code>int</code> are passed by copy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x): x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Same for lists:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(l): l <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>f(l)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> l <span style="color:#f92672">==</span> [<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>However, values inside the list are passed by reference:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(l): l[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>f(l)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> l <span style="color:#f92672">==</span> [<span style="color:#ae81ff">2</span>]
</span></span></code></pre></div><p>Don&rsquo;t know about you, but this leaves a bad taste in my mouth.
The reason is that the logic is purely artificial, somebody came up with those rules.
That&rsquo;s exactly the reason you have to do <code>===</code> instead of <code>==</code> in JavaScript or that Java does <strong>Referential Equality</strong> instead of <strong>Structural Equality</strong> (that&rsquo;s the reason you have to write <code>s1.equals(s2)</code> instead of <code>s1 == s2</code>).</p>
<p>The ability to freely mutate state coupled with unintuitive semantics makes <em>reasoning</em> about programs hard.
Reasoning is the ability to tell if the code is correct or not, especially useful when debugging.</p>
<p>In fact, humans are really bad with reasoning.
Most of the logical thinking that we do is in the prefrontal cortex, the front of the brain, its highest layers.
Essentially, this part of the brain evolved last and is quite recent.
Forcing that part of the brain to work is quite difficult.
We didn&rsquo;t evolve to solve math problems naturally, compared to breathing uncounciously, for example, that&rsquo;s why math is difficult in general.</p>
<p>But we have tools to aid us in that.
Here is the tool: <code>=</code>.</p>
<p>&ldquo;Looks like&hellip; an assignment?&rdquo; you ask yourself.
No, no, it is not an assignment, it is <em>equality</em>.</p>
<p>The ability to tell that two unrelated things are actually the same opens up a myriad of possibilities.
On a side note, people who keep arguing that &ldquo;you can&rsquo;t understand me&rdquo; or cultural isolutionism or whatever, they are essentially robbing people of the tools necessary to understand the world, but that is a story for another day.</p>
<p>For example:</p>
<pre tabindex="0"><code>sum(angles of triange) = 180°
</code></pre><p>Here we establish an equality.
While it may seem trivial, but it is useful, if you know first two angles, using this equality you can find the third angle:</p>
<pre tabindex="0"><code>a + b + c == 180 =&gt; c = 180 - a - b
</code></pre><p>Or take physics for example.
We all may have seen this equation:</p>
<pre tabindex="0"><code>F = ma
</code></pre><p>Newton&rsquo;s Second law.
When I first saw this, I didn&rsquo;t pay much attention.
Of course, this equation gets introduced in a rather boring context, seemingly no use outside of simple kinematics.</p>
<p>But take another example:</p>
<pre tabindex="0"><code>F = kx
</code></pre><p>This is a description of Hooke&rsquo;s law, i.e. what force does the spring exert when displaced by the distance of <code>x</code>.
Again, what of it?</p>
<p>See, the <code>=</code> symbol is actually really powerful.
Because we know that those two equations are basically the same, we can combine them:</p>
<pre tabindex="0"><code>F = ma
F = kx
-------
ma = kx
</code></pre><p>Seems boring, but with this we can find answer to a question, &ldquo;What is the acceleration of the object of mass <code>m</code> attached to a spring with a constant factor of <code>k</code> and displaced by <code>x</code> meters?&rdquo;.
Just basic algebra and voila!</p>
<pre tabindex="0"><code>(ma) / m = (kx) / m =&gt; a = kx / m
</code></pre><p>Now just plug in numbers and find the answer.</p>
<p>Interestingly, physics is quite &ldquo;functional&rdquo;, in a mathematical sense.
The whole science in general is established on the shoulders of equality, or rather equational reasoning.
By measuring things and comparing them with others or saying that one is equal to another, we establish connections.
And turns out, those connections are quite strong.
So, the next time you&rsquo;re wondering why do you need to learn physics: this is why.
Understand that things are interconnected. Discover the power of equational reasoning.</p>
<p>Let us move on.</p>
<p>Unfortunately, the application of equational reasoning in programming is rather limited.
In the presence of the side-effects it is even impossible:</p>
<pre tabindex="0"><code>print(&#34;Hello World!&#34;) ??? print(&#34;Goodbye World!&#34;)
</code></pre><p>How do you even compare those things?</p>
<p>While comparison for those kinds of things is not well defined, we can compare the values:</p>
<pre tabindex="0"><code>&#34;Hello World!&#34; != &#34;Goodbye World!&#34;
</code></pre><p>Side-effects complicate things, they complicate equational reasoning, they complicate reasoning in general.
And they put implicit restrictions that you can&rsquo;t easily verify:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">...</span> <span style="color:#75715e"># some value</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span></code></pre></div><p>Again, back to our example.
Can you tell what this code does?
Can you find a mistake in it?</p>
<p>Probably not.</p>
<p>What about this?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">g</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello filesystem!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;file.txt&#34;</span>)
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span></code></pre></div><p>Now do you see the problem?
We are writing to a closed file.
The correct order must be this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">g</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello filesystem!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;file.txt&#34;</span>)
</span></span><span style="display:flex;"><span>g(x) <span style="color:#75715e"># swapped</span>
</span></span><span style="display:flex;"><span>f(x) <span style="color:#75715e"># places</span>
</span></span></code></pre></div><p>This was an easy example, but the arbitary invoking of side-effects from virtually anywhere can cause problems even on this scale.
This requires us to read ALL the code to find bugs.
Now you see why the job of software developer is so difficult?
Because you&rsquo;re bad at it.</p>
<p>If the functions were pure, the order wouldn&rsquo;t be so important, or rather the order of the functions would be <em>explicit</em>.</p>
<p>Take this imaginary example:</p>
<pre tabindex="0"><code>(f(x) + g(x)) * (k(x) - h(x))
</code></pre><p>All the functions are pure and perform some computations.
It is clear to see that it doesn&rsquo;t matter if we perform <code>f(x)</code> first or <code>g(x)</code>, or <code>h(x)</code> or <code>k(x)</code>.
However, it is also clear that we must first do <code>f(x) + g(x)</code> and <code>k(x) - h(x)</code> before we can multiply them, or that we must perform the computations of the functions if we want to do the addition or the subtraction.</p>
<p>With pure functions there are only computations, and with computations the order is described by data dependency.</p>
<p>Data dependency is when you need to calculate <code>y</code>, but that <code>y</code> depends on <code>x</code>, i.e. <code>y = f(x)</code>.
But if <code>x</code> depends on some other argument <code>u</code>, i.e. <code>x = g(u)</code>, then you get a clear dependency, or an order:</p>
<pre tabindex="0"><code>y = f(g(u))
</code></pre><p>Simple?
Simple.</p>
<p>Hopefully at this point it is clear why we don&rsquo;t like mutation, because mutation implies state and state complicates our code in many unpredictable ways.</p>
<p>That&rsquo;s why we as functional programmers tend to use <em>immutable</em> variables.
In the dicitionary, <code>immutability</code> is defined as a quality of not changing, staying the same.</p>
<p>If we take a problem of the form:</p>
<pre tabindex="0"><code>x + 3 = y =&gt; x = ?
</code></pre><p>While there are many values that <code>x</code> can take, once it is taken, it doesn&rsquo;t change.
That&rsquo;s the beauty of the variables and how they should be used.</p>
<p>Of course, the question is, how do you write a code with variables that don&rsquo;t change?
Simple, just create a new variable.
And if that variable needs to change, create a new variable for that.</p>
<p>I know, it will be difficult initially.
But once you start doing it, you&rsquo;ll notice it that since your variables are immutable, it becomes easy to <em>reason</em> about the program.</p>
<p>So, at this point, we are ready to cut-off our first part of the intro into functional programming:</p>
<ol>
<li>Use pure functions</li>
<li>Fuctions that do side-effects are impure</li>
<li>Impure function called inside pure function makes pure function impure</li>
<li>Use immutable variables</li>
<li>Don&rsquo;t read from global variables</li>
<li>Pass all variables used through input arguments to make function pure</li>
<li>If side-effects are not observable from outside, the function is pure</li>
</ol>
<p>Even if you don&rsquo;t progress further than this, if you just do those when you can, you&rsquo;ll already see the benefit.
That&rsquo;s how I started my journey into functional programming.
With a small step.
It&rsquo;s fine if it will be your only step.</p>
<p>And for those who are still onboard, let us move on.</p>
<h1 id="higher-order-functions">Higher order functions<a href="#higher-order-functions" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Functional programmers are all about making things better.
The problem is that we don&rsquo;t know how to make things better.
So we tend to explore different ideas.
And most of them don&rsquo;t work.
But some turn out to be surprisingly effective.
So much so, the other languages tend to get those ideas into their own languages and then when you try to argue why you should learn a proper functional programming language, people look at you like crazy, saying that they already have all the fancy functional programming stuff in their language and that they already know what it is, while their code is still 90% imperative and state mutating shit.
Sorry, nasty flashbacks.</p>
<p>Anyhow, one of the sources of bugs is the constant repitition.
There are many boilerplate code that you have to write for some reason, and that people hope that AI will manage all of those things.</p>
<p>Boilerplate code is such a problem, seemingly most of the research in computer science is about making the code-reuse as easy as possible.
Remember inheritence?
Its main selling point was the easy code reuse: just inherit from the class whose code you want to use.
It took people a while to realize that it is a bad idea <del>composition over inheritence</del>.</p>
<p>I know it is hard to tell, but functional programmists are also human.
And turns out we also don&rsquo;t like boilerplate code.</p>
<p>And so, we found our ways around it.
The reason people don&rsquo;t know about it or they have difficulties understanding that concept is because of heavy influence of C.
People know functions from C (which are actually procedures, i.e. variables for storing code), so the things that C funcitons don&rsquo;t do must be impossible.</p>
<p>However, that is not the case.
You know, we have dependency injection of our own.</p>
<p>Let&rsquo;s take a look back at one of our examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>As you can see, those two functions are basically the same.
The only difference is how we go through the range.
So this function could be abstracted like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_over_range</span>(l, _range):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> _range:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>So now if you want to do summation from left to right or right to left, you just pass the proper range, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sum_generic(l, range(len(l)))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># or</span>
</span></span><span style="display:flex;"><span>sum_generic(l, range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span></code></pre></div><p>But that doesn&rsquo;t look so nice, especially since you may easily forget which argument is which.
There are ways to do that, but we don&rsquo;t have necessary tools to do that just yet.
So let&rsquo;s come back to that problem later.</p>
<p>Believe it or not, but you&rsquo;ve already been exposed to functional programming in your school.
You probably know this symbol: <code>Σ</code>.
Unfortunately, it doesn&rsquo;t look so nice in this blog post and I haven&rsquo;t figured how to draw LaTeX expressions using JavaScript <del>(damn you, webpack!)</del>.
So let&rsquo;s write it like this:</p>
<pre tabindex="0"><code>  N
 sum { i } = N * (N + 1) / 2
i = 1
</code></pre><p>The way we would write in Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_n</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> x
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span></code></pre></div><p>This is good.
But now imagine that we have to sum squares:</p>
<pre tabindex="0"><code>  N              N(N + 1)(2N + 1)
 sum { i * i } = ----------------
i = 1                   6
</code></pre><p>No problem, let&rsquo;s write it in Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sq</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> x <span style="color:#f92672">*</span> x
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span></code></pre></div><p>Nice, easy-peasy. But now we are asked to sum the square roots:</p>
<pre tabindex="0"><code>  N
 sum { sqrt(i) } = ???
i = 1
</code></pre><p>While I don&rsquo;t know the equation for that, we can still write the code that does this for us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sqrt</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> sqrt(x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span></code></pre></div><p>It was easy, but hopefully you&rsquo;re starting to see the problem now.
Let&rsquo;s look at the code that we&rsquo;ve written:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_n</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> x
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sq</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> x <span style="color:#f92672">*</span> x
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sqrt</span>(l):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> sqrt(x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span></code></pre></div><p>We wrote basically the same code several times.
The only thing that is changing is the term that we sum over.
The terms are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">*</span> x
</span></span><span style="display:flex;"><span>sqrt(x)
</span></span></code></pre></div><p>Let&rsquo;s look at the mathematical expressions:</p>
<pre tabindex="0"><code>  N
 sum { i }
i = 1

  N
 sum { i * i }
i = 1

  N
 sum { sqrt(i) }
i = 1
</code></pre><p>Those are awfully similar as well, and the only parts that are changing are:</p>
<pre tabindex="0"><code>i
i * i
sqrt(i)
</code></pre><p>They are basically the same!
That is not a coincidence.</p>
<p>Let&rsquo;s look at the same part of the mathematical expression:</p>
<pre tabindex="0"><code>  N
 sum { ... }
i = 1
</code></pre><p>What this expression says, is to sum the terms described in the <code>{...}</code>.
In fact, we can write it like this:</p>
<pre tabindex="0"><code>  N
 sum  f(i)
i = 1
</code></pre><p>Turns out, we can do the same in the Python code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_generic</span>(l, f):
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> f(x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s
</span></span></code></pre></div><p>It is basically the same code, with some key difference: we are passing <code>f()</code> to <code>sum_generic()</code>.</p>
<p>&ldquo;Passing functions as arguments?&rdquo; you might be asking.
If it is your first time seeing this, this is a quite important and powerful idea that you&rsquo;ll be seeing often.</p>
<p>Now we can write our <code>sum_n()</code>, <code>sum_sq()</code> and <code>sum_sqrt()</code> in terms of <code>sum_generic()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_n</span>(l):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum_generic(l, <span style="color:#66d9ef">lambda</span> x: x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sq</span>(l):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum_generic(l, <span style="color:#66d9ef">lambda</span> x: x <span style="color:#f92672">*</span> x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_sqrt</span>(l):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum_generic(l, <span style="color:#66d9ef">lambda</span> x: sqrt(x))
</span></span></code></pre></div><p>Here <code>lambda</code> is just a function that accepts an argument x.
Essentially lambda is an anonymous function.</p>
<p>In functional programming we use functions for almost everything, even minute things, but it is still difficult to come up with meaningful names, so <code>lambda</code> is a way to create functions on the fly (and not give them names).</p>
<p>Now the obligatory explanation of higher ordered functions.</p>
<p>In the C language, functions are just a way for you to structure sequence of instructions.
You just give them a name and then invoke those instructions with a name.
In a sense, you could write down those instructions with a macros instead, and they would still act the same.</p>
<p>However, higher ordered functions allow you several things:</p>
<ul>
<li>They can accept other functions as their input arguments</li>
<li>They can return functions as a result</li>
<li>Those functions can be stored in a variable</li>
</ul>
<p>Hopefully you can see that the idea of the higher ordered function is not as scary as it seems, although the words may sound scary or obscure (math people are meanies, I&rsquo;m sorry).</p>
<p>Higher ordered functions are such a powerful and useful idea, that people would hack Python to provide those capabilities, by generating code that is similar to lambdas and then evaluate it, or by changing AST, despite Guido&rsquo;s thinking otherwise about lambdas.
In the end, Guido allowed it, but the lambdas are half-assed, unfortunately.
This is something we have to live with.</p>
<p>Additionally, higher ordered functions exist even in C++ (since C++11!).
While their type is difficult to nail down properly, you can use templates to help you out:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fn<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> some_function<span style="color:#f92672">&lt;</span>Fn<span style="color:#f92672">&gt;</span>(Fn f, <span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> some_function([](<span style="color:#66d9ef">int</span> x){ <span style="color:#66d9ef">return</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> }, <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>While the idea of higher order functions may seem simple, there&rsquo;s one important reason that many math people get overly excited about them: when providing a function <code>f()</code>, you can create a new function <code>g()</code> that can do some more extended things, more than <code>f()</code> could!
We&rsquo;ll see examples of it in the future, if you stick around, but for now just keep the idea in the back of your mind.</p>
<p>Now, the question is: how exactly do you use the higher ordered functions?</p>
<p>Well, you may have had this thought a lot: &ldquo;Okay, let&rsquo;t write <code>for</code> again&hellip;&rdquo;, and then you&rsquo;d write a code similar to this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(a)):
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># busy doing computations with a[i]</span>
</span></span><span style="display:flex;"><span>  b[i] <span style="color:#f92672">=</span> <span style="color:#f92672">...</span> <span style="color:#75715e"># do some computation</span>
</span></span></code></pre></div><p>From what I can see, this can be abstracted away like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(a)):
</span></span><span style="display:flex;"><span>  b[i] <span style="color:#f92672">=</span> f(a[i])
</span></span></code></pre></div><p>where <code>f()</code> is some function that does all the computations that we did.</p>
<p>Let&rsquo;s write a function that abstracts away this boilerplate code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map</span>(a, f):
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> len(a)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i, x <span style="color:#f92672">in</span> enumerate(a):
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> f(x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> b
</span></span></code></pre></div><p>The reason we picked the name <code>map</code> is because map is a name often used for this kind of function: which takes some function <code>f()</code> and applies it to each element of some list <code>a</code> and produces a new list <code>b</code>.</p>
<p>In reality, <code>map</code> doesn&rsquo;t need to work on lists only, but this, and the reason why this function is called <code>map</code> will be covered later.</p>
<p>On the side note, the more declarative way to write this, is to do it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map</span>(a, f):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [f(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> a]
</span></span></code></pre></div><p>If it trips you up, just stop and think for a while.
If it doesn&rsquo;t make sense, think of a set theory.
What is a set theory?
Well, set theory is what happens when you try to give names to things that you took for granted.</p>
<p>Anyway, there&rsquo;s a function called <code>map</code>, that does the similar thing as the <code>map</code> that we defined.
The only difference, is that while our versions return <code>list</code>, the Python versions return an iterator.
The reason will become obvious later, but if you want to use python versions, don&rsquo;t forget to transform them to list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>list(map(<span style="color:#f92672">...</span>))
</span></span></code></pre></div><p>So, map is one of the functions that we often use, because it comes from the imperative for loop.
Another thing that we would often do is something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> a:
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">+=</span> f(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># do something with s</span>
</span></span></code></pre></div><p>This is something that functional programmers also often use.
The names are <code>reduce()</code>, <code>fold()</code>, <code>left_fold()</code>, <code>right_fold()</code>, etc.
Let&rsquo;s write our own:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reduce</span>(a, f, initial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>  acc <span style="color:#f92672">=</span> initial
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> a:
</span></span><span style="display:flex;"><span>    acc <span style="color:#f92672">=</span> f(acc, x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> acc
</span></span></code></pre></div><p>Here <code>f(acc, x)</code> is a function that takes two parameters:</p>
<ul>
<li>The accumulator (<code>acc</code>)</li>
<li>The value (<code>x</code>)</li>
</ul>
<p>Essentially the function <code>f()</code> tells the reduce how to combine, or <code>reduce</code> the values in the list to one value.
So if we want to write a sum function, we need to write how to combine the values into a sum:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addition</span>(acc, x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> acc <span style="color:#f92672">+</span> x
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum</span>(l):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> reduce(l, addition, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>sum([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])
</span></span></code></pre></div><p>We can describe many different functions using <code>reduce()</code>.
For example we can calculate the length of the array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">length</span>(acc, _):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> acc <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">len</span>(l):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> reduce(l, length, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>len([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])
</span></span></code></pre></div><p>Essentially, for every element in the list we do <code>+1</code> to the accumulator.
That is in the essence the definition of the length of the list.</p>
<p><code>reduce()</code> is a ubiquious tool in the toolbox of functional programmers, so get used to it.
<code>fold</code> is just another way to say <code>reduce</code>: the list is being <code>fold</code>ed into a single value, instead of being <code>reduce</code>d.</p>
<p>While this makes sense, what about <code>fold_left</code> and <code>fold_right</code>?</p>
<p>Since the functions <code>fold_left</code> and <code>fold_right</code> are pure, they can be rewritten like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fold_left (l, f, init) <span style="color:#f92672">=</span> f(f(f(f(init, l[<span style="color:#ae81ff">0</span>]), l[<span style="color:#ae81ff">1</span>]), l[<span style="color:#ae81ff">2</span>]), <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>fold_right(l, f, init) <span style="color:#f92672">=</span> f(f(f(f(init, l[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]), l[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]), l[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>]), <span style="color:#f92672">...</span>)
</span></span></code></pre></div><p>If it doesn&rsquo;t make sense, then assuming that <code>∘</code> is some arbitary binary operator and that all types are consistent, then we can rewrite it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fold_left (l, <span style="color:#960050;background-color:#1e0010">∘</span>, init) <span style="color:#f92672">=</span> ((((init <span style="color:#960050;background-color:#1e0010">∘</span> l[<span style="color:#ae81ff">0</span>]) <span style="color:#960050;background-color:#1e0010">∘</span> l[<span style="color:#ae81ff">1</span>]) <span style="color:#960050;background-color:#1e0010">∘</span> l[<span style="color:#ae81ff">2</span>]) <span style="color:#960050;background-color:#1e0010">∘</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>fold_right(l, <span style="color:#960050;background-color:#1e0010">∘</span>, init) <span style="color:#f92672">=</span> (<span style="color:#f92672">...</span> <span style="color:#960050;background-color:#1e0010">∘</span> (l[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>] <span style="color:#960050;background-color:#1e0010">∘</span> (l[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#960050;background-color:#1e0010">∘</span> (l[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#960050;background-color:#1e0010">∘</span> init))))
</span></span></code></pre></div><p>This is something called equational reasoning.
By equalizing two sides, we can say that one is equal to another.
This is a powerful tool in the hands of a functional programmer.
Pay close attention to that.</p>
<p>What it tells us in this case, is that the <code>fold_left</code> and <code>fold_right</code> behave as if inserting some binary operator between each of the elements in the list.
The difference, is that in case of <code>fold_left</code>, we are moving from left to right.
The <em>associativity</em> is <code>left</code>.</p>
<p>In case of <code>fold_right</code> we are moving from right to left.
The <em>associativity</em> is <code>right</code>.</p>
<p>If it feels arbitary, the reason is because it is.
I may be wrong, so when you&rsquo;re using your language&rsquo;s <code>fold_left</code> and <code>fold_right</code>, please consult the documentation.</p>
<p>And another thing, I may have lied about <code>reduce</code> and <code>fold</code>.
They are not exactly the same thing.</p>
<p>In case of <code>fold</code>, you have to provide an initial element.
But in case of <code>reduce</code>, the initial element is the first (or last) element of the list.</p>
<p>Anyway, nice to know, right?</p>
<p>Well, there&rsquo;s another function that we often use and in fact gets implemented in almost every other mainstream language.
The use case for that function, I&rsquo;ll be honest, not so clear, until you try to use it.
But here it is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">magical_function</span>(l, p):
</span></span><span style="display:flex;"><span>  res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> p(x) <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>      res <span style="color:#f92672">=</span> res <span style="color:#f92672">+</span> [x]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>Now, what is function <code>p()</code>?
In mathematical language this is called a <em>predicate</em>.
It is a fancy name for a function who&rsquo;s return type is a <code>bool</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">p</span>(x: any) <span style="color:#f92672">-&gt;</span> bool:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># predicate function</span>
</span></span></code></pre></div><p>You may have seen it, but more like part of an SQL query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> name <span style="color:#66d9ef">FROM</span> accounts <span style="color:#66d9ef">WHERE</span> name <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;D%&#39;</span> <span style="color:#75715e">-- select all names starting with &#34;D&#34;
</span></span></span></code></pre></div><p>In Python, equivalent imperative code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>names_starting_with_d <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> acc <span style="color:#f92672">in</span> accounts:
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> name_of(acc)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> name<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#34;D&#34;</span>):
</span></span><span style="display:flex;"><span>    names_starting_with_d<span style="color:#f92672">.</span>append(name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># use names_starting_with_d</span>
</span></span></code></pre></div><p>Kinda boilerplatey, eh?
Compared to nice SQL version.</p>
<p>In my case, I often used this function when working with a set of data received from some REST API and then making sure it matches some specific criteria, because the data was really volatile and came in different shapes.
<code>filter</code> is what brought back sense and structure into my dataflow, even if I had to remove bad apples.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>l <span style="color:#f92672">=</span> list(range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">11</span>))
</span></span><span style="display:flex;"><span>is_even <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x: x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>print(magical_function(l, is_even)) <span style="color:#75715e"># prints [2, 4, 6, 8, 10]</span>
</span></span></code></pre></div><p>There&rsquo;s another way to achieve this result, using list comprehensions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print([x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">if</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span><span style="color:#75715e"># prints [2, 4, 6, 8, 10]</span>
</span></span></code></pre></div><p>Overall the syntax for list comprehensions is way better in Python because it is functional and declarative by design.
However, composing them is a pain, especially when you don&rsquo;t know how exactly the variables get captured, so you have to do alpha-conversion by hand (another fancy name for renaming variables to avoid confusion and conflicts).</p>
<p>This is nice and dandy, but what so special about them?
Well, nothing really, the ideas are simple.
We will get into more into the implications once we get a stronger base, but for now, just use the functions however you like.
Afterall, the joy of learning is in experimenting and making mistakes.
The most important aspects to keep in mind, is that the most important is that the functions are pure, we are just transforming the data, and we do it without changing the data we were not supposed to change (immutability, remember?).</p>
<p>So, when you try to do more and more declaratively, you&rsquo;ll realize that you need more and more functions.</p>
<p>For example, you have a list <code>['a', 'b', 'c', 'd']</code>, and you want it to have dashes interspersed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> intersperse([<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>], <span style="color:#e6db74">&#39;-&#39;</span>) <span style="color:#f92672">==</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;-&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;-&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;-&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>]
</span></span></code></pre></div><p>Or for example you have two lists and you want to zip them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> zip([<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>], [<span style="color:#e6db74">&#39;d&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;f&#39;</span>]) <span style="color:#f92672">==</span> [(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>), (<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>), (<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;f&#39;</span>)]
</span></span></code></pre></div><p>Or you want to shift the elements in the list by some <code>n</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> shift([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>], <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>There are many functions that are simple, but can be quite powerful.</p>
<p>Again, to make the most use of them, the idea is to make them composable.</p>
<p>While the functions shown in the examples are not higher-ordered functions like <code>map</code>, <code>reduce</code> and <code>filter</code>, there are many functions that you need to use to achieve your goals and simply using those 3 won&rsquo;t be enough, so keep your eyes and mind open.</p>
<p>Also, there are some performance implications for using those functions: they are working on immutable lists, so in theory it means a new copy each and every time.</p>
<p>For that reason, there are several things that you can do:</p>
<ul>
<li>Minimize the amount of data you work on: instead of using <code>map</code> and then <code>filter</code>, try <code>filter</code>ing first and then <code>map</code>ping.</li>
<li>If you have several <code>map</code> functions, try to turn it into one <code>map</code> (and suffer style deductions):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>map(f, map(g, map(h, l))) <span style="color:#f92672">~&gt;</span> map((<span style="color:#66d9ef">lambda</span> x: f(g(h(x)))), l)
</span></span></code></pre></div><ul>
<li>If you really need performance, then use side-effects like mutation, but make sure that the function is pure when observed from <em>outside</em>!
Make sure the side effects don&rsquo;t leak outside of your function.</li>
<li>Perform actions in parallel (if they can be done so, like <code>map</code> and <code>reduce</code>, and <code>filter</code>)</li>
</ul>
<p>If still, none of the solutions are fast enough, try to think if you really need that speed.
And if you do, well, you are free to abandon the purity and composability alltogether.
The most important part is that you know what you&rsquo;re doing.</p>
<p>You&rsquo;re a professional after all.</p>
<p>Well, we&rsquo;re almost done with the higher ordered functions.
Let&rsquo;s just cover some of the concepts and ideas that rear their heads here and there all over the place in functional programming languages: <em>currying</em> and <em>piping</em>.</p>
<p>They are simple, trust me.</p>
<p>One of the reasons you weren&rsquo;t able see all the interesting functional programming ideas is because the languages themselves don&rsquo;t actively push you towards discovering those ideas, or worse yet, actively prevent you from coding in a pure and manageable style.</p>
<p>So those things you haven&rsquo;t see, well, because people usually don&rsquo;t code like that.</p>
<p>You remember the talk about functions being composable?
Well, the composability is really the important aspect that we are trying to achieve (sometimes to our own detriment).
The more we code with simple functions, the more we feel the need to compose functions.
But if we can&rsquo;t compose functions, we curse, give up hope and get angry at the functional programming style for being useless and wasting our precious time that we could have spent on TikTok, Instagram and Twitter instead.</p>
<p>Imagine some magical function like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>res <span style="color:#f92672">=</span> pipe(accounts,[
</span></span><span style="display:flex;"><span>  get_boys,
</span></span><span style="display:flex;"><span>  get_adults,
</span></span><span style="display:flex;"><span>  extract_names,
</span></span><span style="display:flex;"><span>  names_starting_with_a,
</span></span><span style="display:flex;"><span>  capitalize
</span></span><span style="display:flex;"><span>])
</span></span><span style="display:flex;"><span>print(res)
</span></span></code></pre></div><p>While we don&rsquo;t know how those <code>get_boys</code>, <code>get_adults</code>, <code>extract_names</code> etc. are implemented, we kind of get the idea of what is going on.
This code is easy to understand.
One would say that it is encapsulation (which I think it is not, it is just good code).</p>
<p>This thing is called <code>pipe</code>, and the process of using <code>pipe</code> is called <em>piping</em> (I told you it was easy).
The idea is that we take the output of the previous function and make it an input of the next function.
It is a <code>pipe</code> as in bash, shell, etc.
Please tell me you know what bash is&hellip;
We provide initial argument (in this case <code>accounts</code>), and then pass it to an initial function and then go on.</p>
<p>This is simple to understand, but we have a problem: the application of the function must be delayed somehow.</p>
<p>Well, it is simple, if we know what <em>currying</em> is (no, it has nothing to do with curry, and no, I don&rsquo;t know why it is called <code>currying</code>, please don&rsquo;t ask me that).</p>
<p>If you start to get into Haskell, you&rsquo;ll start to see something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span></code></pre></div><p>This is how type signatures are done in Haskell.
When I was looking at that, I couldn&rsquo;t understand why it is done like this.</p>
<p>If you don&rsquo;t want to understand why it is done like that, then the simple explanation that the last item is theh return type, and everything before that is the type that it accepts:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">^</span>      <span style="color:#f92672">^</span>      <span style="color:#f92672">^</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span>      <span style="color:#f92672">|</span>      <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span>      <span style="color:#f92672">|</span>  return <span style="color:#66d9ef">type</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span>    arg2
</span></span><span style="display:flex;"><span>      arg1
</span></span></code></pre></div><p>Quite simple.</p>
<p>The code for that function looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> x y <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
</span></span></code></pre></div><p>In Python it would be something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(x, y): <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span></code></pre></div><p>Except it is not.</p>
<p>In Python all functions are uncurried by default.</p>
<p>In Haskell all functions are curried by default.</p>
<p>So the functions are not equivalent.
If we want to write a similar function, we need to write something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(y):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> f
</span></span></code></pre></div><p>Now it is equivalent.</p>
<p>Are you asking &ldquo;why?&rdquo;?</p>
<p>Well, in Haskell we can write like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add3</span>       <span style="color:#f92672">=</span> add <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">seven</span>      <span style="color:#f92672">=</span> add3 <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">also_seven</span> <span style="color:#f92672">=</span> add <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p>Now, since our Python function is curried, we can do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>add3       <span style="color:#f92672">=</span> add(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>seven      <span style="color:#f92672">=</span> add3(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>also_seven <span style="color:#f92672">=</span> add(<span style="color:#ae81ff">3</span>)(<span style="color:#ae81ff">4</span>)
</span></span></code></pre></div><p>What I did just now is called <em>partial application</em>.
It is when I apply function <em>partially</em>, i.e. I don&rsquo;t give it all the arguments immediately, but do it in steps.
One of reasons for doing so is:</p>
<ul>
<li>Sometimes arguments are not available immediately</li>
<li>You have a list of arguments that you always pass. You can partially apply those values and create functions that accept only arguments that really matter</li>
<li>We can now do piping</li>
</ul>
<p>Before that, let&rsquo;s get back to our type signatures in Haskell:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">f</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b
</span></span></code></pre></div><p>This is a generic type signature in Haskell which says that <code>f</code> is a function from type <code>a</code> to type <code>b</code>, i.e. it accepts an argument of type <code>a</code> and the return type is <code>b</code>.</p>
<p>Now, let&rsquo;s look at this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> c
</span></span></code></pre></div><p>This is another generic functions that accepts two arguments of type <code>a</code> and <code>b</code> and produces type <code>c</code>.</p>
<p>Now, <code>-&gt;</code> is actually an operator, a function operator.
There are implicit parentheses placed in the last type signature, let&rsquo;s make them explicit.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> (b <span style="color:#f92672">-&gt;</span> c))
</span></span></code></pre></div><p>In fact, <code>-&gt;</code> is right associative.
Another fact, <code>b -&gt; c</code> is just another type, so this is the equivalent thing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> d <span style="color:#f92672">=</span> b <span style="color:#f92672">-&gt;</span> c
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> d
</span></span></code></pre></div><p>Now, the magic.
When we have a function of type <code>a -&gt; b</code> and we provide it with <code>a</code>, what we get is <code>b</code>.
So by this logic, if we take <code>a -&gt; d</code> and provide it <code>a</code>, we get <code>d</code>.
But <code>d</code> is actually <code>b -&gt; c</code>, so we actually get another function.</p>
<p>So now hopefully you see why we written the Python code that way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(y):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> f
</span></span></code></pre></div><p>When we first supply <code>x</code>, we as a result get a new function which now accepts <code>y</code>.
Once we get both <code>x</code> and <code>y</code>, we can evaluate the result.</p>
<p>With this we can do piping.
Let&rsquo;s write out those functions first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_boys</span>(accounts):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> accounts[<span style="color:#e6db74">&#39;boys&#39;</span>]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_adults</span>(boys):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> boys <span style="color:#66d9ef">if</span> boys[<span style="color:#e6db74">&#39;age&#39;</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span>]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">extract_names</span>(boys):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [x[<span style="color:#e6db74">&#39;name&#39;</span>] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> boys]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">names_starting_with_a</span>(names):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> names <span style="color:#66d9ef">if</span> x<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#f92672">or</span> x<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;A&#39;</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">capitalize</span>(names):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [x<span style="color:#f92672">.</span>upper() <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> names]
</span></span></code></pre></div><p>This is good.</p>
<p>Actually, function with one argument can be used in a pipe.
So let&rsquo;s write a <code>pipe</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pipe</span>(v, l):
</span></span><span style="display:flex;"><span>  res <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> f(res)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>What we essentially did is create a function that takes the output value of a function and makes it an input for the next function.
Essentially what <code>pipe</code> function is supposed to do.</p>
<p>Now, if the functions had to take more arguments, we would be in a bit of a trouble.
Again, because functions are uncurried by default, the Python would complain that we applied less arguments than we should have.</p>
<p>Let&rsquo;s make a function that curries other functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">curry_that</span>(f):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(l):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(x):
</span></span><span style="display:flex;"><span>      args <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> [x]
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> f(<span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bar
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> foo
</span></span></code></pre></div><p>This is essentially a poor man&rsquo;s <code>curry</code>.</p>
<p>What we are doing here, is that we are taking a function <code>f</code>, and then stage it to accept arguments in two ways:</p>
<ul>
<li>The initial list of arguments, except for the last one</li>
<li>The last argument</li>
</ul>
<p>After all the arguments are passed to the function, it will collect all the arguments into the list, and then expand them using the <code>*</code> operator.</p>
<p>This is how we would use it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">triple_sum</span>(a, b, c):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>t_sum_curry <span style="color:#f92672">=</span> curry_that(triple_sum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(pipe(<span style="color:#ae81ff">3</span>, [t_sum_curry([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>])]))
</span></span></code></pre></div><p>It is a mess, I know.
But then again, you should use better languages.
Hopefully, you are starting to see why I don&rsquo;t like Python.</p>
<p>There are better alternatives in the <code>PyMonad</code> library, like <code>@curry</code> decorator.
Look up the documentation if you&rsquo;re interested.</p>
<p>Now, hopefully you understand those tools and they will be useful to you <del>or you finally decided to code in the better programming language</del>.</p>
<p>We are almost there, I can see the light.</p>
<h1 id="composing-with-side-effects">Composing with side-effects<a href="#composing-with-side-effects" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Now.
If you have thought that the FP guys are crazy, hopefully you&rsquo;re going to end up with a ton of evidence on your hands to finally lock us away into the depths of the abyss, where we truly belong.
Or you might have discovered something new, interesting and useful, which, you know, is also good.</p>
<p>There are three things that make functional programming as functional as it gets (or not):</p>
<ul>
<li>Immutability</li>
<li>Composition</li>
<li>Purity</li>
</ul>
<p>Different languages tend to pull on those different things in different proportions.
For example Lisp allows you to do side-effects and mutate variables.
Clojure on the other hand is all about immutability.
Haskell is about managing those side-effects and maintaining purity.
And OCaml is like, let me just code the way I want: it can do all of those things, but decide not to if it doesn&rsquo;t want to.</p>
<p>But then again, there are things that are really important: composability.</p>
<p>Hopefully from the previous experiences you&rsquo;ve realized that the composability is a good thing and actually helps us to write simpler code: if you can actually write your code in terms of simpler functions that are composable, this is what you would do instead of writing a wall of code and keeping that state in your head all the time.</p>
<p>However, hopefully that you&rsquo;ve also realized that composition works nicely if the functions are <em>pure</em>.
To maintain some sense of purity, you need <em>immutability</em>: you can&rsquo;t have values changing suddenly underneath you.</p>
<p>That&rsquo;s why those things are important and why references are dangerous.
If you don&rsquo;t manage those things, then the simple act of composing will make the debugging difficult.
You won&rsquo;t be able to know what to trust, not much better than the imperative or OOP style.</p>
<p>So okay, you&rsquo;ll try to keep your functions pure to keep them composable.
But what if you have to compose functions that <em>do have</em> side-effects?</p>
<p>Well, luckily for you, there are people much smarter than you and I, who are paid to solve those kinds of problems, and their solutions are then integrated into languages or thrown to the side with many people not understanding why the hell do they need a PhD to write a <code>&quot;Hello World&quot;</code> to the console.</p>
<p>So we will start simple, and hopefully you&rsquo;ll see the beauty.</p>
<p>Let&rsquo;s take the simple act of getting an Nth element in the list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_nth</span>(l, n):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> l[n]
</span></span></code></pre></div><p>Well, the code is simple, right?
Time to go home?</p>
<p>Well, there are obvious problems that you may also see: what if the Nth element doesn&rsquo;t exist?
Well, let&rsquo;s strengthen our code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_nth</span>(l, n):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(l) <span style="color:#f92672">&gt;</span> n:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l[n]
</span></span></code></pre></div><p>Well, okay, now the function doesn&rsquo;t raise an exception if the Nth element doesn&rsquo;t exist.
But what happens instead?
If we try to use that element, we will get another type of exception: something to do with <code>NoneType</code>.
How do you handle that?</p>
<p>Well, at this point most people (including naive and young me) would just say &ldquo;Fuck it&rdquo; and code around this limitation, while keeping it in mind.</p>
<p>In the end, we have some specific goal in mind, not just a function that needs to access some Nth element.
And so we would write around that limitation and we would achieve our goal.</p>
<p>And all would be nice if that was a throwaway script.
However more often than not, the code would become a part of a critical infrastructure.
A ton more code would be written on top of that code, making it more difficult and more dangerous to change the code.</p>
<p>My single <code>F</code> in the whole undergraduate degree came from the course where I had to choose an open-source project and contribute to it.
I made a grave mistake to take my favorite Python project: Deluge.
Needless to say, I couldn&rsquo;t make head nor tail of the project, and so I didn&rsquo;t do anything.</p>
<p>So, if the code is bad, it can get really bad.
What would happen first is that you would write a solution for a specific situation.
And then you would need to change it a little.
And then a little more.
Then you would encounter more and more problems, because you&rsquo;re now breaking your invariants that existed only in your head (and not in your type system).
And now simple code that resembled a &ldquo;happy path&rdquo; looks like an amalgamation of <code>if</code>s, <code>try/catch</code> and many more.
And still it is a highly brittle code, a.k.a. legacy code.</p>
<p>Now, the million-dollar question: why is that the case?</p>
<p>Well, we know that it wasn&rsquo;t the case with pure functions.
Pure functions are equivalent and can be substituted by a single value.
We opened a pandora&rsquo;s box when we tried to work with <em>impure</em> functions, or those that have side-effects that are unaccounted for.</p>
<p>On a side-note, the funny thing that would happen at this stage is that people would:</p>
<ul>
<li>hear that the functional programming is well-equipped with solving those kinds of problems,</li>
<li>try out the FP concepts without understanding then</li>
<li>half-assing them</li>
<li>would make even more mess</li>
<li>and then say that it is bad</li>
</ul>
<p>Unfortunately, there is required some background in CS.
But more importantly, there&rsquo;s a specific mindset that is required when doing functional programming.
FP has tendency to push you towards the right direction, but without the understanding, it would be for naught.</p>
<p>But what would functional programmer would think when writing a code like that?</p>
<p>Well.
The first thing is that the question would be: &ldquo;Why are we writing a function that would need to access the Nth element?&rdquo;.</p>
<p>And the answer is: &ldquo;We don&rsquo;t know&rdquo;.
In fact, this function is really generic.
It can be used for any reason.
It is the same question as to why you would use the word &ldquo;long&rdquo;?
Of course, you would use it to say that something is long.
But you could also say that something is <em>longing</em> for something.</p>
<p>You can&rsquo;t just take the word and shoehorn it into a specific domain.
In that way, you can&rsquo;t just take a generic function and assign it implicit assumptions and hope that they won&rsquo;t get broken, because they most certainly will.</p>
<p>Side-effects are those implicit assumptions.
In our <code>get_nth(l, n)</code>, the assumption was that <code>n &lt; len(l)</code>.
We know that everything is going to work if the assumption is correct.
The problem is that we don&rsquo;t know what would happen if the assumption is <em>incorrect</em>.
And usually what happens is the worst.</p>
<p>Usually it is very difficult to debug, because something that was deemed impossible happens.</p>
<p>For that reason when functional programmers write code, they write it with the idea in mind of what is it they are in fact doing.
The reality is getting in the way.
If the programming language has a strong and expressive type system, then basically programmers can write code as if they are writing a mathematical proof that their code is correct.
If not, then, well, you deal with what you have and hope you have good discipline.</p>
<p>So, the question is, how do we deal with side-effects?</p>
<p>The answer is: head-on.
Let&rsquo;s make the side-effects explicit.</p>
<p>Again, there are several ways of doing what I am going to do, but what I&rsquo;m going to show you is the poor man&rsquo;s monads (yeah, those dreaded monads), so that in case of anything, you can at least manage to do something.</p>
<p>So, let&rsquo;s get back to our example of <code>get_nth()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_nth</span>(l, n):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> l[n]
</span></span></code></pre></div><p>So, in a good case, we have our value.
But in a bad case we have to deal with it somehow.
But we can&rsquo;t give anything, because there&rsquo;s nothing.
So let&rsquo;s give <code>nothing</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_nth</span>(l, n):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(l) <span style="color:#f92672">&gt;</span> n:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> some(l[n])
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> none()
</span></span></code></pre></div><p>This is how the functional programmers would do it.</p>
<p>I&rsquo;m pretty sure you&rsquo;re interested in what <code>some()</code> and <code>none()</code> do.
Well, they are simple, but it is not so much important as to what they are, but how they must be used.</p>
<p>Here are their definitions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some</span>(x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#e6db74">&#39;some&#39;</span>, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">none</span>():
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#e6db74">&#39;none&#39;</span>,)
</span></span></code></pre></div><p>Those are the simple tuples.
We will keep our data structures simple.</p>
<p>What we did here, is (implicitly) defined our own type.
This type is sometimes called <code>Option</code>, sometimes <code>Maybe</code>.
But the idea is that this type represents two cases:</p>
<ul>
<li><code>Something</code> exists</li>
<li><code>Nothing</code> exists</li>
</ul>
<p>So, we can wrap the value into our <code>Option</code> type.
To extract it, we can write an extractor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">value_of</span>(opt):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> opt[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>This would work as expected in case of <code>Some</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(value_of(some(<span style="color:#e6db74">&#34;There is some value!&#34;</span>)))
</span></span></code></pre></div><p>However, we would have the same problem in case of <code>None</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(value_of(none())) <span style="color:#75715e"># throws exception</span>
</span></span></code></pre></div><p>So we came back to our problem.</p>
<p>At this point people would give up on FP, saying it is useless.
But what can we do?</p>
<p>Well, it is clear that you&rsquo;re not supposed to work with the underlying representation.
First thing you can do is check if the value is <code>Some</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_some</span>(opt):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> opt[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;some&#39;</span>
</span></span></code></pre></div><p>Then we can try to extract value from <code>Some</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">extract_value</span>(opt, default_value):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> is_some(opt):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> value_of(opt)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> default_value
</span></span></code></pre></div><p>This is better, because it forces us to come up with the default value in case the our option value is actually <code>None</code>.
But this approach requires a discipline.
You must use <code>extract_value()</code> whenever you&rsquo;re working with <code>Option</code> types and not use the underlying structure.
Also, it is not so easy to come up with the default value in each and every case.</p>
<p>There must be a better option.
Instead of extracting the value from the <code>Some</code>s, let&rsquo;s work on <code>Option</code>s directly.
Of course, we can write functions that are aware that their arguments are <code>Option</code> types, but it would quickly become difficult and unwieldy to manage.</p>
<p>Instead, we can write normal functions, and make them work with <code>Option</code> types.</p>
<p>We do this by the use of <strong>functors</strong>.</p>
<p>Now, another scary word.</p>
<p>When functional programmers say something is a <code>functor</code>, what they mean is that there&rsquo;s an associated function <code>map</code>.
And what they also mean, is that the function <code>map</code> has a specific type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> f a <span style="color:#f92672">-&gt;</span> f b
</span></span></code></pre></div><p>Now, you already seen this style of writing type signatures, but it may seem scary, so let me make it less scary.</p>
<p>The first <code>(a -&gt; b)</code> is a function, so the first argument to <code>map</code> is a function.
A higher-ordered function.</p>
<p>Now, what those <code>f a</code> and <code>f b</code> refer to?
Well, the <code>f</code> in <code>f a</code> refers to <code>functor</code>.
Basically a type for which <code>map</code> is defined.
So <code>map</code> requires specific types for which that <code>map</code> is defined.
Good?
Good.</p>
<p>While it is sounds bad, another way to look at it, is that the <code>map</code> generates a specific type of functor, which is dependent on context.</p>
<p>In our case we have <code>Option</code>, so we could have written like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Option</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Option</span> b
</span></span></code></pre></div><p>So now our function <code>map</code> takes some function from <code>a</code> to <code>b</code> and makes it a function that works on <code>Option a</code> and produces an <code>Option b</code>.</p>
<p>For example we can make the function <code>len</code> work on strings that may or may not exist:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Option</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Option</span> <span style="color:#66d9ef">Int</span>
</span></span></code></pre></div><p>That&rsquo;s just one way to look at it.</p>
<p>So, the questions now is: how do we do that?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map_opt</span>(f):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(opt):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_some(opt):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> some(f(value_of(opt)))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> none()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> foo
</span></span></code></pre></div><p>Quite a mess, I mean Python is.
But what is happening, is that we take a function <code>f()</code>, and if our value is <code>Some(x)</code>, we extract that <code>x</code>, apply it to <code>f()</code> via <code>f(x)</code>, and wrap it back into <code>Some()</code> via <code>Some(f(x))</code>.
Otherwise, if it is <code>None</code>, we just pass along that <code>None</code>.</p>
<p>In OCaml this would have been written like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> map f opt <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">match</span> opt <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">None</span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">None</span>
</span></span></code></pre></div><p>In Haskell this would have been written as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> f opt <span style="color:#f92672">=</span> <span style="color:#66d9ef">case</span> opt <span style="color:#66d9ef">of</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">Some</span> x <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Some</span> (f x)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">None</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>Or even like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> f (<span style="color:#66d9ef">Some</span> x) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Some</span> (f x)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">map</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">None</span>     <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>Quite readable, compared to Python, isn&rsquo;t it.
But those codes are equivalent, I assure you.</p>
<p>Now, with this, we can make a function <code>len</code> that works on <code>Option</code>s:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>len_opt <span style="color:#f92672">=</span> map_opt(len)
</span></span></code></pre></div><p>To check that it works, we need to additionally convert our <code>Option</code> to string:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">string_of</span>(opt):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> is_some(opt):
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> value_of(opt)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Some(</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">)&#34;</span><span style="color:#f92672">.</span>format(v)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;None&#34;</span>
</span></span></code></pre></div><p>And now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(string_of(len_opt(some(<span style="color:#e6db74">&#34;Hello World!&#34;</span>)))) <span style="color:#75715e"># prints &#34;Some(12)&#34;</span>
</span></span><span style="display:flex;"><span>print(string_of(len_opt(none(              )))) <span style="color:#75715e"># prints &#34;None&#34;</span>
</span></span></code></pre></div><p>What we did might not seem much, probably because it is simple.
But what is important, is that we have defined functions that work despite the presence of side effects.</p>
<p>If we tried to take the <code>len()</code> of <code>None</code> directly, I&rsquo;m personally not sure what would happen, because I don&rsquo;t want to learn Python, but I suspect that the exception would happen.</p>
<p>However, with <code>len_opt()</code> we have made a <em>total</em> function: that works in every case.
And that is actually very powerful.
We now don&rsquo;t need any <code>try/catch</code>.
The code <em>just works</em>.</p>
<p>Ain&rsquo;t that amazing?
Eh?</p>
<p>Now, with this out of the way, let&rsquo;s cover something else: <code>Applicative Functor</code>.</p>
<p>Another scary term, but it is actually quite simple.</p>
<p>Let&rsquo;s take a look at the <code>map</code> type signature:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> f a <span style="color:#f92672">-&gt;</span> f b
</span></span></code></pre></div><p>And also let&rsquo;s take a look at <code>add</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span></code></pre></div><p>Now, the question, what would happen if we give <code>add</code> to <code>map</code>?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">map</span> add <span style="color:#f92672">::</span> <span style="color:#66d9ef">Option</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Option</span> (<span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>)
</span></span></code></pre></div><p>How did this happen?</p>
<p>Remember that the type of <code>add</code> is <code>Int -&gt; Int -&gt; Int</code>.
If we try to match it with <code>a -&gt; b</code>, then <code>a == Int</code> and <code>b == Int -&gt; Int</code>.</p>
<p>What this means is that we accidentially put a <em>function</em> inside a functor, instead of a value.
What this means <em>for us</em> is that we can&rsquo;t simply apply values to those functions.</p>
<p>So <code>Applicative Functor</code> solves that specific problem: <em>applies</em> values to a function inside a <em>functor</em>.
Here&rsquo;s the type signature for <code>apply</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">apply</span> <span style="color:#f92672">::</span> f (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> f a <span style="color:#f92672">-&gt;</span> f b
</span></span></code></pre></div><p>That&rsquo;s basically it.</p>
<p>In case of an option we can easily write one such <code>apply</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">apply_opt</span>(opt_f, opt_a):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> is_some(opt_f):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> map_opt(value_of(opt_f))(opt_a)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> none()
</span></span></code></pre></div><p>This works because we first check if the <code>opt_f</code> is actually <code>Some(f)</code>, and if it is, then we just convert our <code>a -&gt; b</code> to <code>f a -&gt; f b</code> with <code>map</code>, and then apply <code>f a</code> to it.
If it is <code>None</code>, then it is, well, <code>None</code>.</p>
<p>Important note is that this <code>apply</code> function works with curried functions (you still remember what curried functions are, right?).</p>
<p>So if we have our <code>add</code> function, this is how we would make it work with <code>Option</code>s:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(a):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> foo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_opt <span style="color:#f92672">=</span> map_opt(add)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>one <span style="color:#f92672">=</span> some(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>two <span style="color:#f92672">=</span> some(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(string_of(
</span></span><span style="display:flex;"><span>  apply(add_opt(one), two)
</span></span><span style="display:flex;"><span>))
</span></span></code></pre></div><p>This doesn&rsquo;t look so nice, because it is, well, Python (I feel tired of mentioning and apologizing for Python at this point).</p>
<p>In functional languages like Haskell and OCaml you can define your own custom operators, and in those languages they define <code>apply</code> as such:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&lt;*&gt;</span>) <span style="color:#f92672">=</span> apply
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> x y <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add_opt</span> <span style="color:#f92672">=</span> map add
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(add_opt one) <span style="color:#f92672">&lt;*&gt;</span> two
</span></span></code></pre></div><p>In fact, they define a custom operator for <code>map</code> as well, so this can be rewritten like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&lt;$&gt;</span>) <span style="color:#f92672">=</span> map
</span></span><span style="display:flex;"><span>(<span style="color:#f92672">&lt;*&gt;</span>) <span style="color:#f92672">=</span> apply
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> x y <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">&lt;$&gt;</span> one <span style="color:#f92672">&lt;*&gt;</span> two
</span></span></code></pre></div><p>Now, when I first saw this, I thought it was ugly.
Why would you need to have separate <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>?</p>
<p>The answer is: to satisfy type system.</p>
<p>Sometimes type system is an annoying bitch.
Because reality is an annoying bitch.</p>
<p>But once you overcome that initial barrier and accept zen, you&rsquo;ll start to see the good things.
For example if you had a function that sums 4 numbers instead of 2, you could have written like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add_quad</span> a b c d <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> d
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add_quad</span> <span style="color:#f92672">&lt;$&gt;</span> (<span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;*&gt;</span> (<span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;*&gt;</span> (<span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;*&gt;</span> (<span style="color:#66d9ef">Some</span> <span style="color:#ae81ff">4</span>)
</span></span></code></pre></div><p>So instead of trying to write complex function that is aware of four <code>Option</code>s, we just <code>apply</code> values to our new function.</p>
<p>In Python this&hellip; wouldn&rsquo;t be so nice.</p>
<p>But we can somewhat mitigate it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lift_optA2</span>(f):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(a):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(b):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> apply(map_opt(f)(a), b)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bar
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> foo
</span></span></code></pre></div><p>And now instead of this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>add_opt <span style="color:#f92672">=</span> map_opt(add)
</span></span><span style="display:flex;"><span>print(string_of(
</span></span><span style="display:flex;"><span>  apply(add_opt(one), two)
</span></span><span style="display:flex;"><span>))
</span></span></code></pre></div><p>We can write like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>add_opt <span style="color:#f92672">=</span> lift_optA2(add)
</span></span><span style="display:flex;"><span>print(string_of(
</span></span><span style="display:flex;"><span>  add_opt(one)(two)
</span></span><span style="display:flex;"><span>)) <span style="color:#75715e"># prints &#34;Some(3)&#34;</span>
</span></span></code></pre></div><p>We essentially treat <code>add_opt</code> as if it is a normal <code>add</code>!
This is the power of applicative functors.
We are coding with side effects as if those functions are pure!</p>
<p>If you don&rsquo;t get this, well, take your time, because it is a big deal.
This is what we were getting to all this time.
All the immutability, pure functions and all the higher ordered functions were necessary for us to get to the point were we could write robust code in the face of side-effects.</p>
<p>Now, the last part that is left to understand is the dreaded monads.
When people are talking about <code>monads</code>, what they refer to is two things:</p>
<ul>
<li>constructor (in case of <code>Options</code> is <code>some(x)</code>)</li>
<li>bind (also written as &raquo;= or<code>&gt;&gt;=</code>)</li>
</ul>
<p>What bind essentially does, is sequence functions that do side effects, i.e. functions that are of type <code>a -&gt; f b</code>.</p>
<p>Here how the bind is defined in case of <code>Option</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(opt_a):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(f):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_some(opt_a):
</span></span><span style="display:flex;"><span>      v <span style="color:#f92672">=</span> value_of(opt_a)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> f(v)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> none()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> foo
</span></span></code></pre></div><p>The type signature of <code>bind</code> is this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">bind</span> <span style="color:#f92672">::</span> f a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> f b) <span style="color:#f92672">-&gt;</span> f b
</span></span></code></pre></div><p>So what is effectively does, is take a value in some context (affected by side-effects) and applies a side-effecting function to it.</p>
<p>The weird order of arguments has to do with the fact, that <code>bind</code> is often declared as a custom operator <code>&gt;&gt;=</code> (also written as &raquo;=), this allows to sequence the functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">foo</span> x <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  x <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>v1 <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>  f v1 <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>v2 <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>  g v2 <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>v3 <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> is_even v3 <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    return true
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    h v2
</span></span></code></pre></div><p>This is an imaginary side-effects-aware code in Haskell.
<code>v1</code>, <code>v2</code> and <code>v3</code> refer to values in case the functions before them worked out nicely.
The code follows a &ldquo;happy path&rdquo;, but in case there are problems, they are handled by the <code>bind</code> or the <code>&gt;&gt;=</code> operator in the background.</p>
<p>This is another power of functional programming: you think through the concepts and leverage the power of the ideas to make the programming language work for you, instead against of you.</p>
<p>Now, hopefully you see that the power of <code>Option</code> comes not from the fact that it represents <code>Some</code> and <code>None</code>, but from the way we structure our code in such a way to keep working with those values in a consistent manner.
Despite the presence of the side-effects.</p>
<p>Also, <code>Option</code> is just one side-effect that exists there.
There are many more and they can be as general or as domain-specific as you like.
You can even write a monad to reliably work specifically with a MySQL for example.</p>
<p>The main idea is to be aware of the ideas and side-effects at hand.</p>
<h1 id="bonus-programming-as-proofs">Bonus: programming as proofs<a href="#bonus-programming-as-proofs" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>At this point when you start to take advantage of all the advanced concepts of functional programming and start to read academical papers on CS and Category Theory, you&rsquo;ll start to feel as if you&rsquo;re not programming, but actually writing a proof of the idea that you have in mind and computer is just there to verify your ideas.</p>
<p>And in fact this is not exactly far-fetched.
If you have heard about <code>coq</code>, it does exactly that.
Coq is a proof-assistant.</p>
<p>We have taught computers to verify mathematical proofs for us.
Isn&rsquo;t it marvelous?!</p>
<p>While I&rsquo;m getting into a territory that I don&rsquo;t understand, Coq leverages the Curry-Howard correspondance.
TL;DR it states that properly written computer program corresponds to some mathematical proof.
If you&rsquo;re writing a function of type <code>a -&gt; b</code>, you&rsquo;re actually writing a proof that if <code>a</code>, then <code>b</code>.
In fact, OCaml was initially developed with idea of writing a Coq in it.
So sometimes you can feel the mathematical roots of OCaml and writing in it sometimes feels like writing proofs.
It is not accidential.</p>
<p>Of course, there&rsquo;s no problem if you don&rsquo;t understand this or if it doesn&rsquo;t work in your language: you need sufficiently strong type system to model your propositions.</p>
<p>But the idea is that the types are actually a very strong concept that helps you <em>reason</em> about the programs.
Types are actually so powerful, they can encode the complex logic in their own fact of existance.
This is what classes are supposed to do, but properly using classes at some point becomes just another form of functional programming.</p>
<p>There is a good wealth of materials on type theory.
Good thing that math is thousand years old and that we have much better understanding of it than of Computer Science, isn&rsquo;t it?</p>
<h1 id="closing-thoughts">Closing thoughts&hellip;<a href="#closing-thoughts" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Thank you for reaching till this part.
It must have been some journey, eh?</p>
<p>But if you reached till here, it means that your journey for you is just beginning.
There are still so many things to learn about functional programming.</p>
<p>The thing I like the most is that when I learn more about functional programming, I somehow end up learning more about the world we live in.
I somehow become a bit more profecient in philosophy and reasoning.
I start to understand other people.
I start to understand what the people are trying to do with economies.</p>
<p>It is surprising.</p>
<p>I also start to get appreciation for really good ideas.
When you discover them, you start to squeel with delight.
Because really good ideas are rare, but when you discover one, it sticks with you till the end of your life.</p>
<p>Nothing of this would have been possible without functional programming in my life.</p>
<p>And for you who are coding in Python, try giving other languages a try.
Even if you won&rsquo;t code in them professionally (or ever), at least your proficiency in Python will become better.
What I hate more than Python is bad Python code that makes other people&rsquo;s lives misereable.</p>
<p>Let&rsquo;s try to make the world a better place.</p>
<p>Hope to see you soon&hellip;</p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="/posts/how-and-why-fp/">
                <span class="button__text">How and Why It Took Me One Year to Start Coding in FP Language</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>









<script type="text/javascript" src="/bundle.js" onload="renderMathInElement(document.body);"></script>





  
</div>

</body>
</html>
