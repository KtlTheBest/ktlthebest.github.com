<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>So You Want to Functional Programming :: Terminal</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Hello there, poor soul! How come you found your way to this post? Are you perhaps unhappy with the way programming is done nowadays? Did you perhaps hear someone say that functional programming has all the benefits like:
Simplifying your projects Removing a class of errors and bugs Bringing back joy of programming of early days Well, whether those claims are true or not, you will have to see them for yourself." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/so-you-want-to-fp/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="So You Want to Functional Programming">
<meta property="og:description" content="Hello there, poor soul! How come you found your way to this post? Are you perhaps unhappy with the way programming is done nowadays? Did you perhaps hear someone say that functional programming has all the benefits like:
Simplifying your projects Removing a class of errors and bugs Bringing back joy of programming of early days Well, whether those claims are true or not, you will have to see them for yourself." />
<meta property="og:url" content="/posts/so-you-want-to-fp/" />
<meta property="og:site_name" content="Terminal" />

  
  
  <meta property="og:image" content="/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-01-19 01:03:00 &#43;0900 JST" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/showcase" >Showcase</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/so-you-want-to-fp/">So You Want to Functional Programming</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-01-19</time></div>

  
  


  

  <div class="post-content"><div>
        <p>Hello there, poor soul!
How come you found your way to this post?
Are you perhaps unhappy with the way programming is done nowadays?
Did you perhaps hear someone say that functional programming has all the benefits like:</p>
<ul>
<li>Simplifying your projects</li>
<li>Removing a class of errors and bugs</li>
<li>Bringing back joy of programming of early days</li>
</ul>
<p>Well, whether those claims are true or not, you will have to see them for yourself.
One interesting thing happening is:</p>
<ol>
<li>people who are not into FP think those who are into FP are pretentious pricks who want to feel themselves smarter than everyeone else, while</li>
<li>the guys who are into FP don&rsquo;t understand all the resistance when there&rsquo;s such a wealth of good things about FP and it is actually not as difficult as many people claim.</li>
</ol>
<p>Well, it seems kinda accurate to me.</p>
<p>There was a period in time when I was &ldquo;aggressive&rdquo; trying to get people learn Functional Programming.
Because of me, some people are probably never crossing to our side.</p>
<p>Oopsie-daisy.</p>
<p>But in my defense, some of those people saw the benefits of those ideas, but are in a stage of their lives when they can&rsquo;t afford to learn functional programming.</p>
<p>That is a valid gripe with functional programming that those who are on the other side have: there&rsquo;s just too much to learn.
Of course, you can use <code>map</code>, <code>filter</code>, <code>fold</code>, recursion, immutability, etc. to spice up your code with some functional flavor.
But the problem most advanced of us have with this, is that you won&rsquo;t understand what you&rsquo;re doing and whether the solution you&rsquo;re deploying is the proper one.
Essentially, you&rsquo;re not getting what you were promised: understanding.
But it is too difficult to get all of it right away (thanks OOP).
Blindly deploying all the tools that you&rsquo;ve learned in hopes it will work is not such a good approach, because high chances it is not going to work, but somehow it is the fault of the FP folk who proposed the idea, not the person who couldn&rsquo;t figure out how to use the idea properly.
Speaking from the experience of a friend who tried to make the code in Dart robust by employing a <code>Either</code> type, and who later regretted it, since Dart wasn&rsquo;t developed with FP ideas in mind.</p>
<p>But the problem still persists: functional programming is difficult to grasp.
In truth, functional programming ideas are simple, and possibly much simpler than OOP ideas to understand (I mean understand, not just &ldquo;ahh, I see&rdquo; and forget the next 15 minutes).
But for some people their brains are adamant in not comprehending those simple ideas.
And I don&rsquo;t know why.
Might make a good PhD thesis in Neuroscience, who knows.</p>
<p>So I&rsquo;ll try my best to explain functional programming principles&hellip; in Python.
Nowadays everyone and their grandmother seems to know Python, so it should be no problem.</p>
<h1 id="what-is-the-lesson">What is the lesson?<a href="#what-is-the-lesson" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The most important takeaway from this post is the perspective.
The correct one, hopefully.</p>
<p>The problem with learning functional programming is that its ideas lie on several spectrums of logic, math, computer science and engineering, simultaneously.
Its ideas are so deep, essentially like calculus, and are re-discovered again and again, by many different people, independently.
The book of &ldquo;Clean Code&rdquo; is essentially a pseudo-introduction into functional programming (not that reading that book helped me understand how to go about my code as a kid, but I really liked it nonetheless).</p>
<p>So yeah, there are many ways to look at the concept through many different lenses, and tugging on one concept attracts other concepts and ideas.
That&rsquo;s why when you&rsquo;re learning functional programming, it feels like you have to learn a lot, simultaneously.
Because you kinda do.
Additionally, functional programming tends to attract people who like to explore ideas, which is nice, but they make bad teachers.
That&rsquo;s why we need better teaching materials for functional programming.</p>
<p>At the end of your (beginning of a) journey into functional programming <del>if you make it</del>, you get a sense of understanding.
The world would never be the same.
You&rsquo;ll start to see things that weren&rsquo;t there before.
Like a sixth sense.
And you&rsquo;ll realize that the ideas were in fact quite simple (although not easy to grasp).</p>
<p>You won&rsquo;t get that understanding by just reading one blog post.
Or two.
Or ten.
Or even one or two books.
At least now.
People who get into functional programming claim that Elm is a great gateway drug into functional programming: it is easy and friendly.
The problem is that it is quite niche (for client-side frontend and compiles to JavaScript).
Unless you do just that, you&rsquo;re stuck.
So one of my aspirations is to create a general purpose programming language, that will be a bad functional programming language, but which will make a good start into FP, just like Elm does.
Unfortunately there isn&rsquo;t one (yet), so we&rsquo;ll be using Python.</p>
<p>Remember, the most important takeaway of this blog post is the perspective.
If you get the perspective, a lot of unconnected things will fall into place.</p>
<p>So, let&rsquo;s start.</p>
<h1 id="functions-purity-and-side-effects">Functions, Purity and Side-effects<a href="#functions-purity-and-side-effects" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Just like in OOP, the most basic building block is an object (or a class, I don&rsquo;t know), the most basic building block in functional programming is a&hellip; function.</p>
<p>Don&rsquo;t look at me like that: there are surprisingly many things that you can build with just functions.
In fact, Alonzo Church, academic supervisor of Alan Turing, discovered lambda calculus and showed that it is equivalent to <em>the</em> Turing Machine.
Essentially, what your fancy C++ and other languages can do, functional programming can also do.</p>
<p>The first important point:</p>
<pre tabindex="0"><code>Important point no. 1: Function is all you need
</code></pre><p>Whenever you feel the itch to overcomplicate your solution, try writing a simple function first.</p>
<p>But not just any function.
What we like in functional programming is a <em>pure</em> function.
So, now we are getting jargons territory, let&rsquo;s quickly back it up with examples.</p>
<p>Let&rsquo;s imagine we are trying to write a function that takes the user&rsquo;s name and prints the message of the day:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd</span>(name):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>  motd(<span style="color:#e6db74">&#34;KtlTheBest&#34;</span>)
</span></span></code></pre></div><p>Now, while this example is purely imaginary, the code is emblematic of what people would usually write.
While it is fine, the question is: how do you <em>test</em> this?</p>
<p>&ldquo;What do you mean by <em>test</em>?&rdquo; I hear you asking.
What I&rsquo;m asking is why are you confident that this will work?</p>
<p>&ldquo;Well, I&rsquo;ll run the code and see the result printed in the terminal&hellip;&rdquo;.
Yeah, but when I was initially writing this code, I made a mistake.
I would have to run the code to see the bug.</p>
<p>But what if the code would be more involved?
Say, it would have many functions (or better say <em>procedures</em>) doing many things, tightly coupled and the only way you see the output is by pinging or calling some other guy sitting on another laptop checking the server response.</p>
<p>Doesn&rsquo;t sound so nice now, does it?</p>
<p>&ldquo;Well, that&rsquo;s how the things are&rdquo;.
But we as functional programmers would disagree.
We would say that the reason you are having problems is because most of your functions are <em>impure</em>.
For example:</p>
<ul>
<li><code>print()</code> is an impure function.</li>
<li><code>randint()</code> is an impure function.</li>
<li><code>time.now()</code> is an impure function.</li>
<li><code>input()</code> is an impure function.</li>
<li>Function that fails because it is Tuesday is an impure function.</li>
<li>Function that reads from a global variable is an impure function.</li>
<li>Function that changes the values of input arguments passed by reference is an impure function.</li>
</ul>
<p>Already, in a small function of one line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd</span>(name):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Hello, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name))
</span></span></code></pre></div><p>&hellip; you&rsquo;re already experiencing problems.</p>
<p>So, how do we make this testable?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">motd_pure</span>(name)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">! Have a nice day!&#34;</span><span style="color:#f92672">.</span>format(name)
</span></span></code></pre></div><p>What we are doing instead of printing is <em>returning a string to print</em>.
Printing is not our responsibility now.</p>
<p>Now, to verify the code, we can write something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>  message <span style="color:#f92672">=</span> motd_pure(<span style="color:#e6db74">&#34;KtlTheBest&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">assert</span> message <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Hello, KtlTheBest! Have a nice day!&#34;</span>
</span></span><span style="display:flex;"><span>  print(message)
</span></span></code></pre></div><p>What we made, is essentially made an impure function a <em>pure</em> one.
But as a consequence, this function became <em>testable</em></p>
<p>We also wrote an <code>assert</code> statement that will print <strong>only</strong> if the function <code>motd_pure()</code> is correct (by some arbitrary definition).</p>
<p>And if you have very keen eyes, you&rsquo;ll realize that there&rsquo;s a bug in a <code>motd_pure</code>: I forgot a comma after <code>&quot;Hello&quot;</code>.</p>
<p>But instead of blindly relying on my (or someone else&rsquo;s) eyes, I can ask computer to verify the function and be 100% sure it works only when it is correct.</p>
<p>So with that, let&rsquo;s get into some definitions.</p>
<h2 id="what-is-purity">What is purity?<a href="#what-is-purity" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>When talking about purity, functional programmers refer to pure functions.
By pure functions we mean functions in mathematical sense:</p>
<pre tabindex="0"><code>f(x) = x * x
</code></pre><p>We can also say that pure functions:</p>
<ol>
<li>Output of the pure function <em>always</em> depends solely on <em>input</em> arguments.</li>
<li>It has no <em>observable</em> side-effects.</li>
</ol>
<p>Let&rsquo;s look at the function again.
If we try to substitute numbers, we get different values:</p>
<pre tabindex="0"><code>f(1)  = 1  * 1  = 1
f(2)  = 2  * 2  = 4
f(10) = 10 * 10 = 100
f(n)  = n  * n  = n * n
</code></pre><p>Here, the result of <code>f(x)</code> depends solely on <code>x</code>.
Another interesting observation is that we can evaluate <code>f(x)</code> infinitely many times, and the result would always be the same: <code>x * x</code>.</p>
<p>This is a nice property to have.</p>
<p>&ldquo;Are there functions that don&rsquo;t behave like that?&rdquo; you may ask.
To which I&rsquo;ll show you this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>DEBUG <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>(x):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> DEBUG <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> x
</span></span></code></pre></div><p>Now, if we evaluate this function like this: <code>foo(3)</code>, we may get <code>9</code>, but when we run it again, <code>f(3) = -3</code>.
Now, we have two different values for <code>foo(3)</code>.
This is not a pure function.
This function has an implicit <em>state</em>.
Implicit, because it is not observable from the function signature (input and output arguments), but if you run it, you&rsquo;ll feel the effects (for example different values for the same input arguments).</p>
<p>Second line says that the function must not have <em>observable</em> side-effects.
Let me show you:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>I&rsquo;ll give you a little sneak-peek, but <em>mutation</em> of a variable (i.e. <code>x = 1; x = 2; assert x != 1</code>) is a <em>side-effect</em> and thus leads to impure functions.
So while we are doing a side-effect, we essentially have pure functions.</p>
<p>For the same list <code>l</code> the results of the functions would be the same.
On a side note, we are doing the order in different ways in both functions, but since the functions are pure and the addition is <em>commutative</em>, i.e. the <code>x + y = y + x</code>, we can say:</p>
<pre tabindex="0"><code>sum_left_to_right(l) == sum_right_to_left(l)
</code></pre><p>However, if we were to add <code>print(&quot;Currently on: {}&quot;.format(i))</code> into the loop, the functions would become impure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Currently on: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(i))
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span></code></pre></div><p>First of all, the functions are doing printing, which is side-effect by definition.
But even if we compare by the side-effects, they would still be different, even if the sum is the same:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_left_to_right</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  to_print <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l)):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Currently on:</span>
</span></span><span style="display:flex;"><span>    to_print<span style="color:#f92672">.</span>push(i)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (sum, to_print)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum_right_to_left</span>(l):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  to_print <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(l) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Currently on:</span>
</span></span><span style="display:flex;"><span>    to_print<span style="color:#f92672">.</span>push(i)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> l[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (sum, to_print)
</span></span></code></pre></div><p>If we compare them, the results will not be the same (in general):</p>
<pre tabindex="0"><code>sum_left_to_right(l) != sum_right_to_left(l)        |l| &gt; 1
</code></pre><p>This is dandy and all, but what&rsquo;s the use, you may ask?
Well, to answer that, we need to cover one more case of side-effect: mutating variables.</p>
<p>You may have seen this millions of times:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>What this does, is that it &ldquo;creates&rdquo; a variable named <code>x</code> and assigns it a value of <code>1</code>.
After that it <em>mutates</em> its value to <code>x + 1</code>.</p>
<p>From the mathematical point of view this expression doesn&rsquo;t make sense.
There&rsquo;s no value of <code>x</code> in <code>ℤ</code>, <code>ℕ</code>, <code>ℚ</code>, <code>ℝ</code> or <code>ℂ</code> that has this property (except if you do modulo 1, but that&rsquo;s useless).</p>
<p>The thing is, the ability to freely mutate state is the source of many software bugs.
Of course, you may not believe me, since I don&rsquo;t have enough experience writing software, but if you try to look at it yourself, you&rsquo;ll see that I&rsquo;m right.</p>
<p>As for me, everytime I am forced to write in Python or any similar languages with hard-to-understand semantics (i.e. you look at the code and have no idea what will happen), I dread inside.</p>
<p>Let&rsquo;s look at this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">...</span> <span style="color:#75715e"># some value</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># x = ???</span>
</span></span></code></pre></div><p>The thing is with Python, is that you don&rsquo;t know or can&rsquo;t be sure.
You don&rsquo;t know, and compiler doesn&rsquo;t know either.</p>
<p>Simple values like <code>int</code> are passed by value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x): x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Same for lists:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(l): l <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>f(l)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> l <span style="color:#f92672">==</span> [<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>However, values inside the list are passed by reference:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(l): l[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>f(l)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> l <span style="color:#f92672">==</span> [<span style="color:#ae81ff">2</span>]
</span></span></code></pre></div><p>Don&rsquo;t know about you, but this leaves a bad taste in my mouth.</p>
<p>The reason is that the logic is purely artificial, somebody came up with those rules.
That&rsquo;s exactly the reason you have to do <code>===</code> instead of <code>==</code> in JavaScript or that Java does <strong>Referential Equality</strong> instead of <strong>Structural Equality</strong> (that&rsquo;s the reason you have to write <code>s1.equals(s2)</code> instead of <code>s1 == s2</code>).</p>
<p>The ability to freely mutate state coupled with unintuitive semantics makes <em>reasoning</em> about programs hard.
Reasoning is the ability to tell if the code is correct or not, especially useful when debugging.</p>
<p>In fact, humans are really bad with reasoning.
Most of the logical thinking that we do is in the prefrontal cortex, the front of the brain, its highest layers.
Essentially, this part of the brain evolved last and is quite recent.
Forcing that part of the brain to work is quite difficult.
We didn&rsquo;t evolve to solve math problems naturally, compared to breathing uncounciously, for example, that&rsquo;s why math is difficult in general.</p>
<p>But we have tools to aid us in that.
Here is the tool: <code>=</code>.</p>
<p>&ldquo;Looks like&hellip; an assignment?&rdquo; you ask yourself.
No, no, it is not an assignment, it is <em>equality</em>.</p>
<p>The ability to tell that two unrelated things are actually the same opens up a myriad of possibilities.
On a side note, people who keep arguing that &ldquo;you can&rsquo;t understand me&rdquo; or cultural isolutionism or whatever, they are essentially robbing people of the tools necessary to understand the world, but that is a story for another day.</p>
<p>For example:</p>
<pre tabindex="0"><code>sum(angles of triange) = 180°
</code></pre><p>Here we establish an equality.
While it may seem trivial, but it is useful, if you know first two angles, using this equality you can find the third angle:</p>
<pre tabindex="0"><code>a + b + c == 180 =&gt; c = 180 - a - b
</code></pre><p>Or take physics for example.
We all may have seen this equation:</p>
<pre tabindex="0"><code>F = ma
</code></pre><p>Newton&rsquo;s Second law.
When I first saw this, I didn&rsquo;t pay much attention.
Of course, this equation gets introduced in a rather boring context, seemingly no use outside of simple kinematics.</p>
<p>But take another example:</p>
<pre tabindex="0"><code>F = kx
</code></pre><p>This is a description of Hooke&rsquo;s law, i.e. what force does the spring exert when displaced by the distance of <code>x</code>.
Again, what of it?</p>
<p>See, the <code>=</code> symbol is actually really powerful.
Because we know that those two equations are basically the same, we can combine them:</p>
<pre tabindex="0"><code>F = ma
F = kx
-------
ma = kx
</code></pre><p>Seems boring, but with this we can find the answer to a question, &ldquo;What is the acceleration of the object of mass <code>m</code> attached to a spring with a constant factor of <code>k</code> and displaced by <code>x</code> meters?&rdquo;.</p>
<p>Just basic algebra and voila!</p>
<pre tabindex="0"><code>(ma) / m = (kx) / m =&gt; a = kx / m
</code></pre><p>Now just plug in numbers and find the answer.</p>
<p>Interestingly, physics is quite &ldquo;functional&rdquo;, in a mathematical sense.
The whole science in general is established on the shoulders of equality, or rather equational reasoning.
By measuring things and comparing them with others or saying that one is equal to another, we establish connections.
And turns out, those connections are quite strong.
So, the next time you&rsquo;re wondering why do you need to learn physics: this is why.
Understand that things are interconnected.
Discover the power of equational reasoning.</p>
<p>Let us move on.</p>
<p>Unfortunately, the application of equational reasoning in programming is rather limited.
In the presence of the side-effects it is even impossible:</p>
<pre tabindex="0"><code>print(&#34;Hello World!&#34;) ??? print(&#34;Goodbye World!&#34;)
</code></pre><p>How do you even compare those things?</p>
<p>While comparison for those kinds of things is not well defined, we can compare values:</p>
<pre tabindex="0"><code>&#34;Hello World!&#34; != &#34;Goodbye World!&#34;
</code></pre><p>Side-effects complicate things, they complicate equational reasoning, they complicate reasoning in general.
And they put implicit restrictions that you can&rsquo;t easily verify:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#f92672">...</span> <span style="color:#75715e"># some value</span>
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span></code></pre></div><p>Again, back to our example.
Can you tell what this code does?
Can you find a mistake in it?</p>
<p>Probably not.</p>
<p>What about this?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">g</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello filesystem!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;file.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>)
</span></span><span style="display:flex;"><span>f(x)
</span></span><span style="display:flex;"><span>g(x)
</span></span></code></pre></div><p>Now do you see the problem?
We are writing to a closed file.
The correct order must be this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">g</span>(x):
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;Hello filesystem!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;file.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>)
</span></span><span style="display:flex;"><span>g(x) <span style="color:#75715e"># swapped</span>
</span></span><span style="display:flex;"><span>f(x) <span style="color:#75715e"># places</span>
</span></span></code></pre></div><p>This was an easy example, but the arbitary invoking of side-effects from virtually anywhere can cause problems even on this scale.
This requires us to read ALL the code to find bugs.
Now you see why the job of software developer is so difficult?
Because you&rsquo;re bad at it.</p>
<p>If the functions were pure, the order wouldn&rsquo;t be so important, or rather the order of the functions would be <em>explicit</em>.</p>
<p>Take this imaginary example:</p>
<pre tabindex="0"><code>(f(x) + g(x)) * (k(x) - h(x))
</code></pre><p>All the functions are pure and perform some computations.
It is clear to see that it doesn&rsquo;t matter if we perform <code>f(x)</code> first or <code>g(x)</code>, or <code>h(x)</code> or <code>k(x)</code>.
However, it is also clear that we must first do <code>f(x) + g(x)</code> and <code>k(x) - h(x)</code> before we can multiply them, or that we must perform the computations of the functions if we want to do the addition or the subtraction.</p>
<p>With pure functions there are only computations, and with computations the order is described by data dependency.</p>
<p>Data dependency is when you need to calculate <code>y</code>, but that <code>y</code> depends on <code>x</code>, i.e. <code>y = f(x)</code>.
But if <code>x</code> depends on some other argument <code>u</code>, i.e. <code>x = g(u)</code>, then you get a clear dependency, or an order:</p>
<pre tabindex="0"><code>y = f(g(u))
</code></pre><p>Simple?
Simple.</p>
<p>Hopefully at this point it is clear why we don&rsquo;t like mutation, because mutation implies state and state complicates our code in many unpredictable ways.</p>
<p>That&rsquo;s why we as functional programmers tend to use <em>immutable</em> variables.
In the dicitionary, <code>immutability</code> is defined as a quality of not changing, staying the same.</p>
<p>If we take a problem of the form:</p>
<pre tabindex="0"><code>x + 3 = y =&gt; x = ?
</code></pre><p>While there are many values that <code>x</code> can take, once it is taken, it doesn&rsquo;t change.
That&rsquo;s the beauty of the variables and how they should be used.</p>
<p>Of course, the question is, how do you write a code with variables that don&rsquo;t change?
Simple, just create a new variable.
And if that variable needs to change, create a new variable for that.</p>
<p>I know, it will be difficult initially.
But once you start doing it, you&rsquo;ll notice it that since your variables are immutable, it becomes easy to <em>reason</em> about the program.</p>
<p>So, at this point, we are ready to cut-off our first part of the intro into functional programming:</p>
<ol>
<li>Use pure functions</li>
<li>Fuctions that do side-effects are impure</li>
<li>Impure function called inside pure function makes pure function impure</li>
<li>Use immutable variables</li>
<li>Don&rsquo;t read from global variables</li>
<li>Pass all variables used through input arguments to make function pure</li>
<li>If side-effects are not observable from outside, the function is pure</li>
</ol>
<p>Even if you don&rsquo;t progress further than this, if you just do those when you can, you&rsquo;ll already see the benefit.
That&rsquo;s how I started my journey into functional programming.
With a small step.
It&rsquo;s fine if it will be your only step.</p>
<p>And for those who are still onboard, let us move on.</p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="/posts/so-you-want-to-fp-ii/">
                <span class="button__icon">←</span>
                <span class="button__text">So You Want to Functional Programming (Part II)</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="/posts/how-and-why-fp/">
                <span class="button__text">How and Why It Took Me One Year to Start Coding in FP Language</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>









<script type="text/javascript" src="/bundle.js" onload="renderMathInElement(document.body);"></script>





  
</div>

</body>
</html>
